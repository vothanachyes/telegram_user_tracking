# Telegram User Tracking - Cursor AI Rules

## Language & Runtime
- **ALWAYS use Python 3.10+** (prefer Python 3.13 when available)
- Use type hints for all function parameters and return values
- Follow PEP 8 style guide strictly
- Use f-strings for string formatting
- Prefer pathlib.Path over os.path for file operations

## Project Context
This is a cross-platform desktop application for tracking Telegram group messages with:
- Flet UI framework for cross-platform GUI
- Pyrogram for Telegram API integration
- Firebase Admin SDK for authentication
- SQLite for local data storage
- Export capabilities (PDF, Excel)

## Architecture & Structure
```
config/          # Configuration, settings, Firebase setup
database/        # SQLite models, db_manager, migrations
services/        # Business logic (auth, telegram, export, media, connectivity)
ui/              # Flet UI components
  ├── pages/     # Main application pages
  ├── components/# Reusable UI components
  └── dialogs/   # Modal dialogs
utils/           # Helpers, validators, constants, credential storage
assets/          # Icons, images
data/            # Database and session files
```

## File Size & Code Organization (CRITICAL)

### File Line Count Limits
**NEVER create files that exceed these limits. Refactor immediately if approaching limits:**

| File Type | Target | Maximum | Action Required |
|-----------|--------|---------|----------------|
| **Service files** | < 300 lines | < 500 lines | Split if > 400 lines |
| **UI Page files** | < 250 lines | < 400 lines | Split if > 350 lines |
| **Component files** | < 200 lines | < 300 lines | Split if > 250 lines |
| **Utility/Helper files** | < 150 lines | < 250 lines | Split if > 200 lines |
| **Model files** | < 200 lines | < 300 lines | Split if > 250 lines |
| **Manager files** | < 300 lines | < 400 lines | Split if > 350 lines |

**SonarQube Compliance**: Files should not exceed 1,000 lines (warning threshold). Target < 500 lines for maintainability.

### Separation of Concerns (MANDATORY)

**Single Responsibility Principle**: Each file must have ONE clear purpose.

#### ❌ AVOID - Mixed Concerns:
```python
# BAD: UI, data fetching, and export logic in one file
class UserDashboardPage:
    def build_ui(self): ...      # UI building
    def fetch_data(self): ...    # Data fetching  
    def export_excel(self): ...  # Export logic
    def handle_events(self): ... # Event handling
```

#### ✅ PREFER - Separated Concerns:
```python
# GOOD: Separate files for each concern
# ui/pages/user_dashboard_page.py - Main orchestration (~200 lines)
# ui/pages/user_dashboard/view_model.py - Data logic (~150 lines)
# ui/pages/user_dashboard/components.py - UI components (~200 lines)
# services/user_dashboard_service.py - Business logic (~150 lines)
```

### When to Split a File

**Split immediately if:**
- File exceeds maximum line count for its type
- File has multiple responsibilities (UI + business logic + data access)
- File mixes concerns (e.g., UI building + data fetching + export)
- File has duplicate code patterns that could be extracted
- File is difficult to test in isolation
- File is hard to navigate or understand

### How to Refactor Large Files

1. **Identify distinct responsibilities** - What does this file do?
2. **Extract to separate modules/classes** - One responsibility per file
3. **Use composition over inheritance** - Compose smaller classes
4. **Maintain clear interfaces** - Well-defined public APIs
5. **Update imports systematically** - Ensure all imports are updated

### Refactoring Patterns

#### For Large UI Pages:
```python
# BEFORE: 800+ lines in one file
class UserDashboardPage:
    # All UI, data, export logic mixed

# AFTER: Separated structure
# ui/pages/user_dashboard_page.py (~200 lines) - Orchestration
class UserDashboardPage:
    def __init__(self):
        self.view_model = UserDashboardViewModel(db_manager)
        self.components = UserDashboardComponents()
    
    def build(self):
        return self.components.build(self.view_model)

# ui/pages/user_dashboard/view_model.py (~150 lines) - Data/State
class UserDashboardViewModel:
    # Data fetching, filtering, state management

# ui/pages/user_dashboard/components.py (~200 lines) - UI Building
class UserDashboardComponents:
    # UI building logic only

# services/user_dashboard_service.py (~100 lines) - Business Logic
class UserDashboardService:
    # Business logic only
```

#### For Large Services:
```python
# BEFORE: 600+ lines with duplicate patterns
class ExportService:
    def export_messages_to_excel(...): ...
    def export_users_to_excel(...): ...
    def export_messages_to_pdf(...): ...
    # 6 similar methods with duplicated formatting code

# AFTER: Strategy pattern with formatters
# services/export/base_exporter.py - Base interface
# services/export/excel_exporter.py - Excel-specific logic
# services/export/pdf_exporter.py - PDF-specific logic
# services/export/formatters/excel_formatter.py - Excel formatting
# services/export/formatters/pdf_formatter.py - PDF formatting
```

### Code Review Checklist

Before committing, verify:
- [ ] File is under maximum line count for its type
- [ ] File has single, clear responsibility
- [ ] No mixing of UI, business logic, and data access
- [ ] Reusable code is extracted to components/utilities
- [ ] File is testable in isolation
- [ ] Related code is grouped logically

### Benefits of Following These Rules

1. **Maintainability** - Easier to understand and modify
2. **Testability** - Smaller units easier to test
3. **Reusability** - Components can be reused
4. **Collaboration** - Multiple developers can work without conflicts
5. **Navigation** - Easier to find relevant code
6. **Code Review** - Smaller diffs easier to review
7. **SonarQube Compliance** - Passes static analysis checks

## Tech Stack Guidelines

### Flet Framework
- Use `ft.` prefix for all Flet components
- Follow reactive state management patterns
- Use `page.update()` sparingly - prefer component-level updates
- Implement proper event handlers with async/await where needed
- Use `ft.Container` with `expand=True` for responsive layouts
- Leverage `ft.Column` and `ft.Row` with proper spacing and alignment

### Pyrogram (Telegram)
- Always handle Pyrogram client lifecycle properly (connect/disconnect)
- Store sessions in `data/sessions/` directory
- Use async/await for all Telegram operations
- Handle API rate limits and errors gracefully
- Check if client is connected before operations

### Firebase Authentication
- Use Firebase Admin SDK (not client SDK)
- Implement single-device session enforcement
- Handle token expiration and refresh
- Secure credential storage using `utils/credential_storage.py`
- Never log or expose Firebase credentials

### SQLite Database
- Use SQLAlchemy ORM (if present) or raw SQL with proper parameterization
- Always use transactions for write operations
- Implement proper connection pooling
- Create indexes for frequently queried columns
- Handle database migrations in `database/migrations/`

## Coding Standards

### Error Handling
- Use try-except blocks for all external operations (API calls, file I/O, database)
- Log errors with proper context using the logging module
- Show user-friendly error messages in UI (snackbars, dialogs)
- Never expose stack traces to end users

### Logging
- Use Python's logging module (configured in main.py)
- Log levels: DEBUG for development, INFO for important events, WARNING for issues, ERROR for failures
- Include context in log messages (user actions, API calls, file operations)
- Log to both file (app.log) and console

### Async/Await
- Use async/await for all I/O operations (Telegram API, file downloads, database queries)
- Don't block the UI thread - use threading or async for long-running tasks
- Properly handle exceptions in async functions
- Use `asyncio.create_task()` for fire-and-forget operations

### Security
- Never hardcode credentials or API keys
- Use environment variables via python-dotenv
- Encrypt sensitive data at rest using cryptography module
- Validate and sanitize all user inputs
- Use parameterized queries to prevent SQL injection

## UI/UX Guidelines
- Support both dark and light themes
- Implement bilingual support (English and Khmer)
- Use consistent spacing and padding (theme.py)
- Show loading indicators for async operations
- Provide feedback for all user actions (success/error messages)
- Implement proper form validation before submission
- Use dialogs for confirmations and detailed views

## File Operations
- Use pathlib.Path for all file paths
- Create directories if they don't exist before writing files
- Handle file encoding properly (UTF-8 default)
- Clean up temporary files after use
- Organize media downloads in `downloads/` with proper structure

## Testing & Quality
- Write defensive code - validate inputs at boundaries
- Handle edge cases (empty lists, None values, network failures)
- Test with both online and offline scenarios
- Verify cross-platform compatibility (Windows, macOS, Linux)

## Dependencies
- Keep requirements.txt updated with exact versions
- Pin major versions to avoid breaking changes
- Document any new dependencies added
- Use virtual environment (venv) for isolation

## Git & Version Control
- Don't commit credentials, API keys, or Firebase config files
- Don't commit data/ directory contents (database, sessions)
- Don't commit app.log or build artifacts
- Follow conventional commit messages

## Performance
- Implement pagination for large datasets
- Use lazy loading for media files
- Cache frequently accessed data
- Optimize database queries with proper indexes
- Batch operations when possible

## Common Patterns

### Creating a new UI page:
```python
import flet as ft
from typing import Optional

class NewPage:
    def __init__(self, page: ft.Page, on_navigate):
        self.page = page
        self.on_navigate = on_navigate
        
    def build(self) -> ft.Control:
        return ft.Container(
            # UI components
        )
```

### Service layer pattern:
```python
class NewService:
    def __init__(self, db_manager):
        self.db = db_manager
        self.logger = logging.getLogger(__name__)
    
    async def operation(self) -> Optional[Result]:
        try:
            # Business logic
            return result
        except Exception as e:
            self.logger.error(f"Operation failed: {e}")
            return None
```

### Database operations:
```python
def get_items(self, filters: dict) -> list:
    with self.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM table WHERE field = ?", (value,))
        return cursor.fetchall()
```

## Build & Distribution
- Use build.py for PyInstaller builds
- Include all assets and dependencies in spec file
- Test executable on target platforms before release
- Follow semantic versioning (MAJOR.MINOR.PATCH)

## When Making Changes
1. Understand the full context before modifying code
2. Maintain consistency with existing patterns
3. Update related documentation if needed
4. Test changes thoroughly (especially UI flows)
5. Consider impact on other components/services
6. Don't break existing functionality

## Remember
- Python 3 is the standard - use modern Python features
- User experience is paramount - make the UI responsive and intuitive
- Security first - protect user credentials and data
- Log everything important - it helps with debugging
- Handle errors gracefully - never crash the app

